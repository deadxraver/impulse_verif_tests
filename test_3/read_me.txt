Тестовый набор:
1. Файлы для сборки (исходные тексты) - Makefile и test_3.c
2. Дамп к программе - получается при сборке.
3. Трасса qemu - можно получить при запуске make run_trace
4. Командные файлы для запуска программы (с отладчиком и без отладчика):

   Сборка теста с отладочными сообщениями (при запуске работает нормально):
   make clean ; make DBG_PRINT=1 all

   Сборка теста без отладочных сообщений (сборка работает нормально, при запуске зависает):
   make clean ; make all

   Запуск elf-файла в qemu.
   Без отладчика:
   $ make run
   С отладчиком (запускаются в разных консолях):
      Сначала (консоль 1):
      $ make debug
      Следом (консоль 2):
      # ./start_gdb_server.sh
   Отладка ведётся в консоли 2.

Программа работает нормально в режиме вывода отладочных сообщений и не работает в режиме без вывода отладочных сообщений.

Вопросы/задания:

1. Как исправить ошибку в программе (чтобы она работала без отладочного вывода)
 - Ошибка исправляется путем оборачивания дебаг вывода в фигурные скобки. Если этого не сделать, то при запуске релизной версии, где макрос заменяется на пустоту, в иф включится инкремент счетчика, т.е. как только мы придем к случаю, когда условие не выполняется, программа уйдет в бесконечный цикл
2. Из-за чего возникает ошибка (зависание сборки с выключенной отладочной печатью)
 - описал выше
3. Пояснить, как работает система сборки с использованием makefile (на данном примере)
 - Пишем make или make all, чтобы собрать программу, после этого мейк проверяет, если .elf файлы аптудейт, то ничего не делает, а если нет, то запускает цель с совпадающим названием. Она в свою очередь проверяет актуальность исходников, и если сборка не нужна, ничего не делает, иначе компилирует программу для риск5 с использованием кросс компилятора, и сохраняет информацию об объектных файлах
4. Рассказать, что такое переменные make, окружения, компилятора (на данном примере)
 - переменные make - используются для вынесения повторяющихся частей кода сборки в отдельные блоки, для удобного использования в различных окружениях, например, объявляем переменную CC, ставим ей значение gcc, таким образом используем стандартный гцц на компьютере, потом перешли на другой компьютер, где бинарник гцц лежит локально, указали путь до него в CC, а потом вообще решили сделать кросс-компиляцию, заменили на gcc с префиксом. Получается, что меняем только содержимое переменных, а сама структура сборки остается неизменной
 - Переменные компилятора - передаем компилятору DDBG_PRINT=1, таким образом, при сборке теста он будет задефайнен, условие выполнится, а значит объявится макрос для дебаг принта
 - Переменные окружения задавали через env.sh, они хранят в себе пути до бинарников, чтобы мы могли писать не полный путь до них, а только названия (простой пример, ls, а не /usr/bin/ls)
